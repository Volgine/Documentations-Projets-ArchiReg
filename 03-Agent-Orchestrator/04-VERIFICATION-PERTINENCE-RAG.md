# üîç V√âRIFICATION DE LA PERTINENCE RAG

**Date** : 21 octobre 2025  
**Status** : ‚úÖ GUIDE COMPLET  
**Objectif** : V√©rifier si le LLM ment ou si les r√©ponses sont bien enrichies avec la s√©mantique

---

## üéØ LES 5 M√âTHODES DE V√âRIFICATION

### **1Ô∏è‚É£ ENDPOINT DEBUG - V√©rification directe**

**URL** : `GET /api/v3/rag/debug-search?query=Code+urbanisme&limit=10`

**Retour** :
```json
{
  "success": true,
  "query": "Code urbanisme",
  "threshold_used": 0.9,
  "total_found": 8,
  "relevant_count": 8,
  "avg_distance": 0.7028,
  "avg_similarity": 0.2972,
  "quality_assessment": {
    "excellent": true,
    "good": false,
    "poor": false,
    "distance_range": "0.7010 - 0.7045"
  },
  "results": [
    {
      "rank": 1,
      "distance": 0.7028,
      "similarity_score": 0.2972,
      "is_relevant": true,
      "title": "Article L111-1 Code Urbanisme",
      "content_preview": "Le territoire fran√ßais est le patrimoine commun...",
      "content_full": "...",
      "metadata": {...},
      "source": "legifrance"
    }
  ]
}
```

**‚úÖ Comment v√©rifier** :
- `is_relevant: true` ‚Üí Distance < 0.85 = pertinent
- `quality_assessment.excellent: true` ‚Üí ‚â•5 r√©sultats pertinents
- `avg_distance: 0.70-0.85` ‚Üí Optimal pour Solon Q8_0
- Comparer `content_full` avec la r√©ponse du LLM

---

### **2Ô∏è‚É£ LOGS BACKEND - Tra√ßabilit√© compl√®te**

**Logs Render** : `mcp_render_list_logs`

**Ce qu'on voit** :
```
‚úÖ Recherche s√©mantique termin√©e : 8 r√©sultats
‚úÖ Threshold : 0.9
‚úÖ Distance : 0.7028
‚úÖ Score : 0.2972
üìä R√©sultat #1 : distance=0.7028, title="Article L111-1"
```

**‚úÖ Comment v√©rifier** :
- `results_count > 0` ‚Üí Semantic search a trouv√© des r√©sultats
- `distance ~ 0.70-0.85` ‚Üí R√©sultats pertinents
- `threshold = 0.9` ‚Üí Configuration correcte
- `total_count = 117148` ‚Üí Base compl√®te index√©e

---

### **3Ô∏è‚É£ QUERY SQL DIRECTE - V√©rit√© absolue**

**Requ√™te Supabase** :
```sql
SELECT 
  id,
  metadata->>'title' as title,
  LEFT(content, 200) as preview,
  embedding <=> '[0.123, 0.456, ...]'::vector as distance,
  1 - (embedding <=> '[0.123, 0.456, ...]'::vector) as similarity
FROM document_chunks
WHERE embedding <=> '[0.123, 0.456, ...]'::vector < 0.9
ORDER BY embedding <=> '[0.123, 0.456, ...]'::vector
LIMIT 10;
```

**‚úÖ Comment v√©rifier** :
1. R√©cup√©rer l'embedding de la query via `/api/v3/rag/debug-search`
2. Ex√©cuter la query SQL directement dans Supabase
3. Comparer les r√©sultats SQL avec les r√©sultats du LLM
4. Si identiques ‚Üí LLM ne ment pas

---

### **4Ô∏è‚É£ COMPARAISON R√âPONSE LLM VS CHUNKS**

**M√©thode** :
1. Appeler `/api/v3/rag/debug-search?query=Code+urbanisme`
2. Noter les `content_full` des 8 r√©sultats
3. Poser la m√™me question au LLM
4. V√©rifier que la r√©ponse LLM contient des √©l√©ments des `content_full`

**‚úÖ Exemple de v√©rification** :

| Chunk trouv√© | Contenu LLM | Match ? |
|--------------|-------------|---------|
| "Le Code de l'Urbanisme regroupe les r√®gles..." | "Le Code de l'Urbanisme (CU) regroupe l'ensemble des r√®gles..." | ‚úÖ OUI |
| "Article L111-1: Principes g√©n√©raux" | "L111-1: Principes g√©n√©raux de l'am√©nagement" | ‚úÖ OUI |
| "PLU d√©finit les zones constructibles" | "Le PLU fixe les r√®gles d'am√©nagement" | ‚úÖ OUI |

**Si 70%+ des chunks sont repris ‚Üí LLM est bien enrichi**

---

### **5Ô∏è‚É£ TEST DE COH√âRENCE TEMPORELLE**

**M√©thode** :
1. Poser une question sur un document r√©cent (ex: "PLU 94220")
2. V√©rifier dans `/api/v3/rag/debug-search` la date `upload_date`
3. Si le LLM cite des infos r√©centes ET que `upload_date` est r√©cent ‚Üí OK
4. Si le LLM cite des infos r√©centes MAIS `upload_date` est ancien ‚Üí LLM invente

**‚úÖ Exemple** :
```json
{
  "query": "PLU Charenton 94220",
  "results": [
    {
      "title": "PLU Charenton-le-Pont 2023-2029",
      "upload_date": "2023-01-15",
      "content": "Le PLU 2023-2029 de Charenton..."
    }
  ]
}
```

**Si le LLM dit "PLU 2023-2029" ET que le chunk existe ‚Üí ‚úÖ Enrichi**  
**Si le LLM dit "PLU 2023-2029" MAIS aucun chunk ‚Üí ‚ùå LLM invente**

---

## üìä M√âTRIQUES DE QUALIT√â RAG

### **Seuils de distance (Solon Q8_0)**

| Distance | Similarit√© | Pertinence | Action |
|----------|------------|------------|--------|
| **0.00-0.50** | 0.50-1.00 | üü¢ Excellent | Utiliser |
| **0.50-0.70** | 0.30-0.50 | üü¢ Tr√®s bon | Utiliser |
| **0.70-0.85** | 0.15-0.30 | üü° Bon | Utiliser |
| **0.85-0.90** | 0.10-0.15 | üü† Moyen | V√©rifier manuellement |
| **0.90-1.00** | 0.00-0.10 | üî¥ Faible | Rejeter |

**Avec seuil 0.9** :
- ‚úÖ On garde uniquement distance < 0.9 (similarit√© > 0.1)
- ‚úÖ En pratique, on trouve surtout 0.70-0.85 (bon √† tr√®s bon)
- ‚úÖ Tr√®s peu de r√©sultats 0.85-0.90 (moyen)

### **Nombre de r√©sultats**

| R√©sultats trouv√©s | Qualit√© | √âvaluation |
|-------------------|---------|------------|
| **‚â•8** | üü¢ Excellent | Beaucoup de contexte |
| **5-7** | üü¢ Tr√®s bon | Suffisant |
| **2-4** | üü° Bon | Minimum acceptable |
| **1** | üü† Moyen | Risque de biais |
| **0** | üî¥ Mauvais | Pas d'enrichissement |

---

## üõ†Ô∏è SCRIPT DE V√âRIFICATION AUTOMATIQUE

### **Python - V√©rification automatique**

```python
import requests
import json

def verify_rag_enrichment(query: str, llm_response: str):
    """
    V√©rifie si la r√©ponse LLM est bien enrichie avec RAG
    
    Returns:
        dict: {
            "is_enriched": bool,
            "confidence": float (0-1),
            "matched_chunks": int,
            "details": {...}
        }
    """
    # 1. R√©cup√©rer les chunks trouv√©s par RAG
    debug_url = f"https://agent-orchestrateur-backend.onrender.com/api/v3/rag/debug-search"
    params = {"query": query, "limit": 10, "similarity_threshold": 0.9}
    
    response = requests.get(debug_url, params=params)
    data = response.json()
    
    # 2. Extraire les contenus des chunks
    chunks = [r["content_full"] for r in data["results"]]
    
    # 3. V√©rifier combien de chunks sont pr√©sents dans la r√©ponse LLM
    matched_chunks = 0
    total_chunks = len(chunks)
    
    for chunk in chunks:
        # Extraire les mots-cl√©s du chunk (simplification)
        keywords = set(chunk.lower().split()[:50])  # 50 premiers mots
        llm_words = set(llm_response.lower().split())
        
        # Calculer intersection
        intersection = keywords & llm_words
        
        # Si >30% des mots du chunk sont dans la r√©ponse LLM
        if len(intersection) / len(keywords) > 0.3:
            matched_chunks += 1
    
    # 4. Calculer confiance
    confidence = matched_chunks / total_chunks if total_chunks > 0 else 0
    
    # 5. √âvaluation
    is_enriched = confidence >= 0.5  # Au moins 50% des chunks utilis√©s
    
    return {
        "is_enriched": is_enriched,
        "confidence": round(confidence, 2),
        "matched_chunks": matched_chunks,
        "total_chunks": total_chunks,
        "quality": data["quality_assessment"],
        "avg_distance": data["avg_distance"],
        "details": {
            "query": query,
            "threshold": 0.9,
            "results_found": data["total_found"],
            "relevant_count": data["relevant_count"],
        }
    }


# Exemple d'utilisation
query = "Code urbanisme"
llm_response = """
Le Code de l'Urbanisme (CU) regroupe l'ensemble des r√®gles relatives √† 
l'am√©nagement du territoire, √† la planification et √† l'instruction des 
projets de construction. Il se compose de parties l√©gislatives (articles L*) 
et r√©glementaires (articles R*).
"""

result = verify_rag_enrichment(query, llm_response)
print(json.dumps(result, indent=2))

"""
Output:
{
  "is_enriched": true,
  "confidence": 0.75,
  "matched_chunks": 6,
  "total_chunks": 8,
  "quality": {
    "excellent": true,
    "good": false,
    "poor": false,
    "distance_range": "0.7010 - 0.7045"
  },
  "avg_distance": 0.7028,
  "details": {
    "query": "Code urbanisme",
    "threshold": 0.9,
    "results_found": 8,
    "relevant_count": 8
  }
}
"""
```

---

## üéØ CHECKLIST DE V√âRIFICATION RAPIDE

### **‚úÖ Avant de faire confiance au LLM**

- [ ] **1. V√©rifier `/api/v3/rag/debug-search`**
  - [ ] `total_found > 0`
  - [ ] `relevant_count >= 2`
  - [ ] `avg_distance < 0.85`
  - [ ] `quality_assessment.excellent` ou `good`

- [ ] **2. V√©rifier les logs backend**
  - [ ] `‚úÖ Recherche termin√©e : N r√©sultats`
  - [ ] `distance ~ 0.70-0.85`
  - [ ] `threshold = 0.9`

- [ ] **3. Comparer r√©ponse LLM vs chunks**
  - [ ] Au moins 50% des chunks mentionn√©s dans la r√©ponse
  - [ ] Vocabulaire technique coh√©rent
  - [ ] R√©f√©rences juridiques pr√©cises (articles, codes)

- [ ] **4. V√©rifier les m√©tadonn√©es**
  - [ ] `source` coh√©rente (legifrance, PLU, etc.)
  - [ ] `upload_date` r√©cente si info r√©cente
  - [ ] `title` correspond au sujet

- [ ] **5. Test de coh√©rence**
  - [ ] R√©ponse diff√©rente si on d√©sactive RAG
  - [ ] R√©ponse identique si on relance la m√™me query
  - [ ] Pas de hallucinations (inventer des articles inexistants)

---

## üö® SIGNES QUE LE LLM MENT

### **üî¥ Alerte rouge - LLM invente**

1. **Aucun r√©sultat RAG** (`total_found = 0`) MAIS r√©ponse d√©taill√©e
2. **Distance > 0.90** MAIS r√©ponse ultra-pr√©cise
3. **Articles cit√©s absents** des chunks trouv√©s
4. **Dates incoh√©rentes** (dit "2023" mais `upload_date = 2015`)
5. **Changement de r√©ponse** si on d√©sactive RAG ‚Üí Ment

### **üü° Alerte jaune - V√©rifier manuellement**

1. **1-2 r√©sultats trouv√©s** seulement
2. **Distance 0.85-0.90** (limite)
3. **R√©ponse g√©n√©rique** (pas de r√©f√©rences pr√©cises)
4. **M√©tadonn√©es vides** ou incoh√©rentes

### **üü¢ Tout va bien - LLM enrichi**

1. **‚â•5 r√©sultats** trouv√©s
2. **Distance 0.70-0.85**
3. **R√©ponse avec r√©f√©rences** (articles, URLs L√©gifrance)
4. **Coh√©rence chunks ‚Üî r√©ponse**

---

## üìà SUIVI QUALIT√â EN CONTINU

### **M√©triques √† suivre**

```sql
-- KPI qualit√© RAG (√† calculer quotidiennement)

-- 1. Taux de r√©ussite recherche s√©mantique
SELECT 
  COUNT(*) FILTER (WHERE results_count > 0) * 100.0 / COUNT(*) as success_rate
FROM search_logs
WHERE created_at > NOW() - INTERVAL '24 hours';

-- 2. Distance moyenne des r√©sultats
SELECT 
  AVG(avg_distance) as global_avg_distance,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY avg_distance) as median_distance
FROM search_logs
WHERE created_at > NOW() - INTERVAL '24 hours'
  AND results_count > 0;

-- 3. Distribution qualit√©
SELECT 
  CASE 
    WHEN avg_distance < 0.70 THEN 'Excellent'
    WHEN avg_distance < 0.85 THEN 'Bon'
    WHEN avg_distance < 0.90 THEN 'Moyen'
    ELSE 'Faible'
  END as quality,
  COUNT(*) as count,
  COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () as percentage
FROM search_logs
WHERE created_at > NOW() - INTERVAL '24 hours'
GROUP BY 1
ORDER BY 1;
```

### **Dashboard Grafana (recommand√©)**

```yaml
metrics:
  - name: rag_search_success_rate
    query: "SELECT COUNT(*) FILTER (WHERE results_count > 0) * 100.0 / COUNT(*) FROM search_logs"
    
  - name: rag_avg_distance
    query: "SELECT AVG(avg_distance) FROM search_logs WHERE results_count > 0"
    
  - name: rag_relevant_count
    query: "SELECT AVG(relevant_count) FROM search_logs WHERE results_count > 0"

alerts:
  - condition: rag_search_success_rate < 80
    severity: warning
    message: "Taux de r√©ussite RAG < 80%"
    
  - condition: rag_avg_distance > 0.85
    severity: warning
    message: "Distance moyenne > 0.85 (qualit√© d√©grad√©e)"
```

---

## üéâ CONCLUSION

**Pour v√©rifier si le LLM ment** :

1. ‚úÖ **Utiliser `/api/v3/rag/debug-search`** (m√©thode la plus simple)
2. ‚úÖ **Comparer chunks vs r√©ponse** (m√©thode la plus fiable)
3. ‚úÖ **V√©rifier les logs** (tra√ßabilit√© compl√®te)
4. ‚úÖ **Calculer le taux de match** (script Python)
5. ‚úÖ **Suivre les KPI** (m√©triques en continu)

**Avec seuil 0.9 et mod√®le Solon Q8_0** :
- Distance **0.70-0.85** = **Excellent** üü¢
- **‚â•5 r√©sultats** trouv√©s = **RAG efficace** üü¢
- **50%+ chunks utilis√©s** = **LLM enrichi** üü¢

**Le LLM ne peut PAS mentir si tu v√©rifies ces 3 points ! üîí**

